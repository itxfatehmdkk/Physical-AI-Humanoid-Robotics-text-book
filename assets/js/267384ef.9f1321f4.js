"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[5568],{2874:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapter6-vla","title":"Chapter 6: Vision-Language-Action (VLA)","description":"LLM-Based Planning","source":"@site/docs/chapter6-vla.md","sourceDirName":".","slug":"/chapter6-vla","permalink":"/physical-ai-humanoid-robotics-text-book/docs/chapter6-vla","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter6-vla.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"title":"Chapter 6: Vision-Language-Action (VLA)"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 5: NVIDIA Isaac Platform","permalink":"/physical-ai-humanoid-robotics-text-book/docs/chapter5-nvidia-isaac"},"next":{"title":"Chapter 7: Capstone: Build an Autonomous Humanoid","permalink":"/physical-ai-humanoid-robotics-text-book/docs/chapter7-capstone"}}');var a=o(4848),t=o(8453);const s={sidebar_position:6,title:"Chapter 6: Vision-Language-Action (VLA)"},r="Chapter 6: Vision-Language-Action (VLA)",l={},c=[{value:"LLM-Based Planning",id:"llm-based-planning",level:2},{value:"Understanding VLA Models",id:"understanding-vla-models",level:3},{value:"Key Characteristics of LLM-Based Planning",id:"key-characteristics-of-llm-based-planning",level:3},{value:"Architecture of VLA Systems",id:"architecture-of-vla-systems",level:3},{value:"Example VLA Architecture",id:"example-vla-architecture",level:3},{value:"Training VLA Models",id:"training-vla-models",level:3},{value:"Challenges in LLM-Based Planning",id:"challenges-in-llm-based-planning",level:3},{value:"OpenAI Whisper Speech-to-Action",id:"openai-whisper-speech-to-action",level:2},{value:"Introduction to Whisper for Robotics",id:"introduction-to-whisper-for-robotics",level:3},{value:"Key Features of Whisper for Robotics",id:"key-features-of-whisper-for-robotics",level:3},{value:"Implementing Whisper in Robotics",id:"implementing-whisper-in-robotics",level:3},{value:"Advanced Whisper Integration",id:"advanced-whisper-integration",level:3},{value:"Challenges with Speech-to-Action",id:"challenges-with-speech-to-action",level:3},{value:"Converting Natural Language \u2192 ROS 2 Action Pipeline",id:"converting-natural-language--ros-2-action-pipeline",level:2},{value:"Natural Language Processing Pipeline",id:"natural-language-processing-pipeline",level:3},{value:"ROS 2 Action Servers and Clients",id:"ros-2-action-servers-and-clients",level:3},{value:"Integration with OpenAI Models",id:"integration-with-openai-models",level:3},{value:"Bipedal Locomotion &amp; Manipulation Planning",id:"bipedal-locomotion--manipulation-planning",level:2},{value:"Bipedal Locomotion Challenges",id:"bipedal-locomotion-challenges",level:3},{value:"Locomotion Planning Approaches",id:"locomotion-planning-approaches",level:3},{value:"Zero-Moment Point (ZMP) Based Control",id:"zero-moment-point-zmp-based-control",level:4},{value:"Model Predictive Control (MPC) for Walking",id:"model-predictive-control-mpc-for-walking",level:4},{value:"Manipulation Planning",id:"manipulation-planning",level:3},{value:"Coordinated Locomotion-Manipulation Planning",id:"coordinated-locomotion-manipulation-planning",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-6-vision-language-action-vla",children:"Chapter 6: Vision-Language-Action (VLA)"})}),"\n",(0,a.jsx)(e.h2,{id:"llm-based-planning",children:"LLM-Based Planning"}),"\n",(0,a.jsx)(e.p,{children:"Vision-Language-Action (VLA) models represent a significant advancement in robotics, bridging the gap between high-level language understanding and low-level motor control. These models enable robots to interpret natural language commands and execute them as sequences of physical actions."}),"\n",(0,a.jsx)(e.h3,{id:"understanding-vla-models",children:"Understanding VLA Models"}),"\n",(0,a.jsx)(e.p,{children:"VLA models are large neural networks that jointly process visual inputs, language instructions, and action outputs. Unlike traditional robotics approaches where perception, planning, and control modules are separate, VLA models learn end-to-end mappings from vision and language to actions."}),"\n",(0,a.jsx)(e.h3,{id:"key-characteristics-of-llm-based-planning",children:"Key Characteristics of LLM-Based Planning"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multimodal Integration"}),": VLA models process visual and linguistic inputs simultaneously"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Zero-Shot Generalization"}),": Ability to follow novel instructions without task-specific training"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-World Grounding"}),": Actions are grounded in real-world visual observations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hierarchical Reasoning"}),": Can decompose complex tasks into primitive actions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"architecture-of-vla-systems",children:"Architecture of VLA Systems"}),"\n",(0,a.jsx)(e.p,{children:"A typical VLA system consists of several components:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Vision Encoder"}),": Processes visual input (images, video) into high-dimensional embeddings"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Language Embedder"}),": Converts natural language instructions into vector representations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fusion Network"}),": Combines visual and language features"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Action Decoder"}),": Generates motor commands based on combined features"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Policy Network"}),": Maps combined features to action parameters"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"example-vla-architecture",children:"Example VLA Architecture"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import torch\nimport torch.nn as nn\nimport torchvision.models as models\n\nclass VisionLanguageActionModel(nn.Module):\n    def __init__(self, action_dim, hidden_dim=512):\n        super().__init__()\n        \n        # Vision encoder (using ResNet as example)\n        self.vision_encoder = models.resnet50(pretrained=True)\n        self.vision_encoder.fc = nn.Identity()  # Remove final classification layer\n        \n        # Language encoder (simplified example)\n        self.language_encoder = nn.LSTM(\n            input_size=300,  # Word embedding dimension\n            hidden_size=hidden_dim,\n            batch_first=True\n        )\n        \n        # Fusion network\n        self.fusion_network = nn.Sequential(\n            nn.Linear(2048 + hidden_dim, hidden_dim),  # ResNet out + LSTM out\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU()\n        )\n        \n        # Action decoder\n        self.action_decoder = nn.Sequential(\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, action_dim)\n        )\n        \n    def forward(self, image, language):\n        # Process visual input\n        visual_features = self.vision_encoder(image)\n        \n        # Process language input\n        language_features, _ = self.language_encoder(language)\n        # Take the last output of LSTM\n        language_features = language_features[:, -1, :]\n        \n        # Fuse visual and language features\n        combined_features = torch.cat([visual_features, language_features], dim=1)\n        fused_features = self.fusion_network(combined_features)\n        \n        # Generate actions\n        actions = self.action_decoder(fused_features)\n        \n        return actions\n\n# Example usage\nmodel = VisionLanguageActionModel(action_dim=7)  # 7-DOF robot arm example\n"})}),"\n",(0,a.jsx)(e.h3,{id:"training-vla-models",children:"Training VLA Models"}),"\n",(0,a.jsx)(e.p,{children:"Training VLA models typically involves:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Collection"}),": Large datasets of demonstrations with visual, language, and action components"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Pre-training"}),": Pre-train vision and language encoders on large datasets"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Fine-tuning"}),": Fine-tune the entire system on robotics-specific data"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Curriculum Learning"}),": Gradually increase task complexity"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"challenges-in-llm-based-planning",children:"Challenges in LLM-Based Planning"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Reality Gap"}),": Models trained in simulation struggle to transfer to the real world"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scalability"}),": Large models require significant computational resources"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Safety"}),": Ensuring actions are safe in unstructured environments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Interpretability"}),": Understanding why models make certain decisions"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"openai-whisper-speech-to-action",children:"OpenAI Whisper Speech-to-Action"}),"\n",(0,a.jsx)(e.p,{children:"Speech interfaces provide a natural way for humans to interact with robotic systems. OpenAI's Whisper model offers state-of-the-art speech recognition capabilities that can be integrated into robotics applications."}),"\n",(0,a.jsx)(e.h3,{id:"introduction-to-whisper-for-robotics",children:"Introduction to Whisper for Robotics"}),"\n",(0,a.jsx)(e.p,{children:"Whisper is a robust automatic speech recognition (ASR) system capable of recognizing speech in various languages and acoustic conditions. When combined with robotics systems, Whisper can transform spoken commands into executable actions."}),"\n",(0,a.jsx)(e.h3,{id:"key-features-of-whisper-for-robotics",children:"Key Features of Whisper for Robotics"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multilingual Support"}),": Recognizes speech in 99 languages"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robustness"}),": Handles various accents, background noise, and acoustic conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time Processing"}),": Can process speech with minimal latency"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Transcription Accuracy"}),": High accuracy even in challenging conditions"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"implementing-whisper-in-robotics",children:"Implementing Whisper in Robotics"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import whisper\nimport torch\nimport rospy\nfrom std_msgs.msg import String\nfrom geometry_msgs.msg import Twist\n\nclass SpeechToActionNode:\n    def __init__(self):\n        rospy.init_node('speech_to_action')\n        \n        # Load Whisper model (choose appropriate model size for your application)\n        self.model = whisper.load_model(\"base.en\")  # For English, adjust as needed\n        \n        # Publishers and subscribers\n        self.cmd_publisher = rospy.Publisher('cmd_vel', Twist, queue_size=10)\n        self.speech_subscriber = rospy.Subscriber('audio_input', String, self.speech_callback)\n        \n        # Command vocabulary for navigation\n        self.navigation_commands = {\n            'forward': (1.0, 0.0, 0.0),  # Linear x, y, z\n            'backward': (-1.0, 0.0, 0.0),\n            'left': (0.0, 0.0, 0.5),    # Angular z\n            'right': (0.0, 0.0, -0.5),\n            'stop': (0.0, 0.0, 0.0)\n        }\n        \n    def speech_callback(self, msg):\n        # Process audio file path from message\n        audio_path = msg.data\n        \n        # Transcribe the audio using Whisper\n        result = self.model.transcribe(audio_path)\n        text = result['text'].strip().lower()\n        \n        rospy.loginfo(f\"Speech recognized: {text}\")\n        \n        # Parse the command and execute action\n        self.parse_and_execute_command(text)\n        \n    def parse_and_execute_command(self, text):\n        # Simple keyword-based command parsing\n        # In practice, this would be more sophisticated\n        for keyword, action in self.navigation_commands.items():\n            if keyword in text:\n                cmd_msg = Twist()\n                cmd_msg.linear.x = action[0]\n                cmd_msg.linear.y = action[1]\n                cmd_msg.linear.z = 0.0\n                cmd_msg.angular.x = 0.0\n                cmd_msg.angular.y = 0.0\n                cmd_msg.angular.z = action[2]\n                \n                self.cmd_publisher.publish(cmd_msg)\n                rospy.loginfo(f\"Executed command: {keyword}\")\n                return\n                \n        rospy.logwarn(f\"Unrecognized command: {text}\")\n\ndef main():\n    node = SpeechToActionNode()\n    rospy.spin()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.h3,{id:"advanced-whisper-integration",children:"Advanced Whisper Integration"}),"\n",(0,a.jsx)(e.p,{children:"For more sophisticated integration, Whisper can be combined with NLP models to understand complex instructions:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import whisper\nimport openai\nfrom transformers import pipeline\n\nclass AdvancedSpeechToAction:\n    def __init__(self, openai_api_key):\n        # Initialize Whisper\n        self.speech_model = whisper.load_model("base")\n        \n        # Initialize NLP pipeline for instruction parsing\n        self.instruction_parser = pipeline(\n            "text-classification", \n            model="microsoft/DialoGPT-medium"\n        )\n        \n        # Set up OpenAI API\n        openai.api_key = openai_api_key\n        \n    def process_speech_command(self, audio_path):\n        # Transcribe speech\n        result = self.speech_model.transcribe(audio_path)\n        text = result[\'text\'].strip()\n        \n        # Use LLM to parse complex instructions\n        response = openai.ChatCompletion.create(\n            model="gpt-3.5-turbo",\n            messages=[\n                {"role": "system", "content": "You are a command parser for a robot. Parse the user\'s natural language command and return a structured action. Respond in JSON format with \'action_type\' and \'parameters\' fields."},\n                {"role": "user", "content": text}\n            ]\n        )\n        \n        # Parse the response and convert to robot action\n        parsed_action = self.parse_command(response.choices[0].message[\'content\'])\n        return parsed_action\n        \n    def parse_command(self, response_text):\n        # Extract structured action from LLM response\n        # Implementation would extract JSON from response_text\n        import json\n        try:\n            action_data = json.loads(response_text)\n            return action_data\n        except:\n            return {"action_type": "unknown", "parameters": {}}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"challenges-with-speech-to-action",children:"Challenges with Speech-to-Action"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Acoustic Conditions"}),": Performance varies with noise and environmental factors"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-Time Processing"}),": Need for low-latency processing in dynamic environments"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Ambient Noise"}),": Background sounds can affect recognition accuracy"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dialects and Accents"}),": Recognition accuracy varies across different speakers"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"converting-natural-language--ros-2-action-pipeline",children:"Converting Natural Language \u2192 ROS 2 Action Pipeline"}),"\n",(0,a.jsx)(e.p,{children:"The conversion of natural language commands to executable ROS 2 actions involves multiple stages of processing and understanding."}),"\n",(0,a.jsx)(e.h3,{id:"natural-language-processing-pipeline",children:"Natural Language Processing Pipeline"}),"\n",(0,a.jsx)(e.p,{children:"The conversion process typically involves several stages:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Speech Recognition"}),": Convert speech to text (if using voice commands)"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Intent Classification"}),": Determine the overall intent of the command"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Entity Extraction"}),": Identify specific objects, locations, or parameters"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Action Mapping"}),": Map the processed command to ROS 2 actions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Execution"}),": Execute the mapped actions in the ROS 2 system"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"ros-2-action-servers-and-clients",children:"ROS 2 Action Servers and Clients"}),"\n",(0,a.jsx)(e.p,{children:"ROS 2 provides action servers and clients for handling long-running tasks:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Pose\nfrom std_msgs.msg import String\nimport json\n\nclass NaturalLanguageActionServer(Node):\n    def __init__(self):\n        super().__init__('natural_language_action_server')\n        \n        # Create action server for navigation tasks\n        self._action_server = ActionServer(\n            self,\n            NavigateWithCommand,\n            'navigate_with_command',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback)\n        \n        # Initialize NLP components\n        self.nlp_processor = NLPProcessor()  # Custom NLP class\n        \n        # Publishers for navigation\n        self.nav_publisher = self.create_publisher(Pose, 'goal_pose', 10)\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject goal requests.\"\"\"\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject cancel requests.\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n    \n    def execute_callback(self, goal_handle):\n        \"\"\"Execute the goal.\"\"\"\n        self.get_logger().info('Executing goal...')\n        \n        # Process the natural language command\n        command_text = goal_handle.request.command\n        parsed_command = self.nlp_processor.parse_command(command_text)\n        \n        # Execute the parsed command\n        result = self.execute_parsed_command(parsed_command)\n        \n        # Return result\n        goal_handle.succeed()\n        result = NavigateWithCommand.Result()\n        result.success = True\n        result.message = f\"Executed command: {command_text}\"\n        return result\n\n    def execute_parsed_command(self, parsed_command):\n        \"\"\"Execute a parsed command.\"\"\"\n        command_type = parsed_command.get('type')\n        \n        if command_type == 'navigation':\n            # Extract goal position\n            x = parsed_command.get('x', 0.0)\n            y = parsed_command.get('y', 0.0)\n            \n            # Create and publish goal pose\n            goal_pose = Pose()\n            goal_pose.position.x = x\n            goal_pose.position.y = y\n            goal_pose.position.z = 0.0\n            self.nav_publisher.publish(goal_pose)\n            \n        elif command_type == 'manipulation':\n            # Handle manipulation commands\n            object_name = parsed_command.get('object')\n            action = parsed_command.get('action')\n            # Implementation for manipulation would go here\n            \n        return True\n\nclass NLPProcessor:\n    \"\"\"Process natural language commands.\"\"\"\n    def __init__(self):\n        # Initialize NLP models\n        pass\n    \n    def parse_command(self, command_text):\n        \"\"\"Parse a natural language command.\"\"\"\n        # This is a simplified example\n        # In practice, you would use more sophisticated NLP techniques\n        \n        command_text_lower = command_text.lower()\n        \n        if 'go to' in command_text_lower or 'navigate to' in command_text_lower:\n            # Extract location (this is a simplified extraction)\n            import re\n            # Simple regex to extract coordinates\n            match = re.search(r'(\\d+\\.?\\d*)\\s*,\\s*(\\d+\\.?\\d*)', command_text)\n            if match:\n                x, y = float(match.group(1)), float(match.group(2))\n                return {\n                    'type': 'navigation',\n                    'x': x,\n                    'y': y\n                }\n            else:\n                # Handle named locations\n                if 'kitchen' in command_text_lower:\n                    return {\n                        'type': 'navigation',\n                        'x': 5.0,\n                        'y': 3.0\n                    }\n                elif 'living room' in command_text_lower:\n                    return {\n                        'type': 'navigation',\n                        'x': -2.0,\n                        'y': 1.0\n                    }\n        \n        elif 'pick up' in command_text_lower or 'grasp' in command_text_lower:\n            # Extract object to manipulate\n            import re\n            # Extract object name\n            match = re.search(r'(?:pick up|grasp|get)\\s+(.+)', command_text)\n            if match:\n                object_name = match.group(1).strip()\n                return {\n                    'type': 'manipulation',\n                    'action': 'pick_up',\n                    'object': object_name\n                }\n        \n        # Default case - unrecognized command\n        return {\n            'type': 'unknown'\n        }\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_server = NaturalLanguageActionServer()\n    rclpy.spin(action_server)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(e.h3,{id:"integration-with-openai-models",children:"Integration with OpenAI Models"}),"\n",(0,a.jsx)(e.p,{children:"For more sophisticated natural language understanding, we can use OpenAI models:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import openai\nimport json\n\nclass OpenAICommandProcessor:\n    def __init__(self, api_key):\n        openai.api_key = api_key\n        \n    def parse_command(self, command_text):\n        """Use OpenAI to parse natural language commands."""\n        prompt = f"""\n        Parse the following natural language command for a robot and return the structured output in JSON format:\n        \n        Command: "{command_text}"\n        \n        Return a JSON object with the following structure:\n        {{\n          "action_type": "navigation | manipulation | interaction | etc.",\n          "parameters": {{\n            "x": float, // If navigation\n            "y": float, // If navigation\n            "object": "string", // If manipulation\n            "action": "string"  // If manipulation\n          }},\n          "confidence": float // Between 0 and 1\n        }}\n        \n        Be precise with the JSON format and only return the JSON object with no additional text.\n        """\n        \n        response = openai.ChatCompletion.create(\n            model="gpt-3.5-turbo",\n            messages=[{"role": "user", "content": prompt}],\n            temperature=0.1  # Low temperature for more deterministic output\n        )\n        \n        try:\n            # Extract JSON from response\n            content = response.choices[0].message[\'content\'].strip()\n            \n            # Sometimes the API might return the JSON wrapped in markdown code blocks\n            if content.startswith(\'```\'):\n                content = content[content.find(\'{\'):content.rfind(\'}\')+1]\n            \n            parsed_command = json.loads(content)\n            return parsed_command\n        except Exception as e:\n            print(f"Error parsing command: {e}")\n            return {\n                "action_type": "unknown",\n                "parameters": {},\n                "confidence": 0.0\n            }\n'})}),"\n",(0,a.jsx)(e.h2,{id:"bipedal-locomotion--manipulation-planning",children:"Bipedal Locomotion & Manipulation Planning"}),"\n",(0,a.jsx)(e.p,{children:"Combining locomotion and manipulation planning in humanoid robots is one of the most challenging problems in robotics, requiring coordination between the robot's ability to move around and interact with objects in its environment."}),"\n",(0,a.jsx)(e.h3,{id:"bipedal-locomotion-challenges",children:"Bipedal Locomotion Challenges"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots face several unique challenges for locomotion:"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Balance"}),": Maintaining stability on two legs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic Walking"}),": Managing the physics of walking"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Terrain Adaptation"}),": Adapting to different surfaces and obstacles"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Energy Efficiency"}),": Minimizing power consumption"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"locomotion-planning-approaches",children:"Locomotion Planning Approaches"}),"\n",(0,a.jsx)(e.h4,{id:"zero-moment-point-zmp-based-control",children:"Zero-Moment Point (ZMP) Based Control"}),"\n",(0,a.jsx)(e.p,{children:"ZMP control ensures the robot maintains balance by keeping the center of pressure within the support polygon:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import numpy as np\n\nclass ZMPBasedWalker:\n    def __init__(self, robot_mass, gravity=9.81):\n        self.mass = robot_mass\n        self.gravity = gravity\n        self.g = gravity\n        self.omega = np.sqrt(self.g / self.mass)  # Simplified omega for ZMP\n        \n    def compute_zmp_reference(self, com_trajectory, com_vel_trajectory, com_acc_trajectory):\n        """\n        Compute ZMP reference from center of mass trajectory\n        This is a simplified version - real implementations are more complex\n        """\n        zmp_ref_x = com_trajectory[:, 0] - (com_acc_trajectory[:, 0] / self.omega**2)\n        zmp_ref_y = com_trajectory[:, 1] - (com_acc_trajectory[:, 1] / self.omega**2)\n        \n        return np.column_stack((zmp_ref_x, zmp_ref_y))\n\n    def generate_foot_steps(self, zmp_reference, step_length=0.3, step_width=0.2):\n        """\n        Generate footstep plan based on ZMP reference\n        """\n        footsteps = []\n        \n        # Simplified footstep generation\n        # In practice, this would implement more sophisticated planning\n        for i, zmp_point in enumerate(zmp_reference):\n            if i % 2 == 0:  # Left foot\n                foot_pos = [zmp_point[0], step_width/2.0, 0.0]\n            else:  # Right foot\n                foot_pos = [zmp_point[0], -step_width/2.0, 0.0]\n                \n            footsteps.append(foot_pos)\n            \n        return footsteps\n'})}),"\n",(0,a.jsx)(e.h4,{id:"model-predictive-control-mpc-for-walking",children:"Model Predictive Control (MPC) for Walking"}),"\n",(0,a.jsx)(e.p,{children:"MPC approaches optimize walking patterns over a prediction horizon:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class ModelPredictiveWalker:\n    def __init__(self, prediction_horizon=20, dt=0.1):\n        self.horizon = prediction_horizon\n        self.dt = dt\n        self.A = np.array([[1, self.dt, self.dt**2 / 2],\n                           [0, 1, self.dt],\n                           [0, 0, 1]])\n        # Simplified dynamics matrix for CoM motion\n        \n    def compute_control_sequence(self, current_state, reference_trajectory):\n        """\n        Compute control sequence using simplified MPC approach\n        """\n        # This is a simplified implementation\n        # Real MPC would solve an optimization problem\n        control_sequence = np.zeros((self.horizon, 2))  # 2D control (x, y)\n        \n        for i in range(self.horizon):\n            # Simplified tracking control\n            error = reference_trajectory[i] - current_state[:2]\n            control_sequence[i] = 2 * error  # Simplified control law\n            \n        return control_sequence\n'})}),"\n",(0,a.jsx)(e.h3,{id:"manipulation-planning",children:"Manipulation Planning"}),"\n",(0,a.jsx)(e.p,{children:"Manipulation planning involves planning robot arm motions to interact with objects:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\n\nclass ManipulationPlanner:\n    def __init__(self, robot):\n        self.robot = robot\n        self.workspace_bounds = {\n            'x': (-0.5, 0.5),\n            'y': (-0.3, 0.3),\n            'z': (0.1, 0.8)\n        }\n        \n    def plan_reach_motion(self, target_pose):\n        \"\"\"\n        Plan arm motion to reach a target pose\n        \"\"\"\n        # Simplified motion planning\n        # In practice, this would use more sophisticated planners like RRT*\n        current_pose = self.robot.get_end_effector_pose()\n        \n        # Linear interpolation in Cartesian space\n        num_steps = 20\n        trajectory = []\n        \n        for i in range(num_steps + 1):\n            t = i / num_steps\n            interpolated_pose = {\n                'x': current_pose['x'] + t * (target_pose['x'] - current_pose['x']),\n                'y': current_pose['y'] + t * (target_pose['y'] - current_pose['y']),\n                'z': current_pose['z'] + t * (target_pose['z'] - current_pose['z'])\n            }\n            trajectory.append(interpolated_pose)\n            \n        return trajectory\n    \n    def plan_grasp(self, object_pose):\n        \"\"\"\n        Plan approach, grasp, and lift motion for an object\n        \"\"\"\n        # Approach position (slightly above the object)\n        approach_pose = object_pose.copy()\n        approach_pose['z'] += 0.15  # 15cm above object\n        \n        # Grasp position (at object height)\n        grasp_pose = object_pose.copy()\n        \n        # Lift position (above object)\n        lift_pose = object_pose.copy()\n        lift_pose['z'] += 0.2  # Lift 20cm\n        \n        # Generate the sequence of motions\n        approach_traj = self.plan_reach_motion(approach_pose)\n        grasp_traj = self.plan_reach_motion(grasp_pose)\n        lift_traj = self.plan_reach_motion(lift_pose)\n        \n        return approach_traj + grasp_traj + lift_traj\n"})}),"\n",(0,a.jsx)(e.h3,{id:"coordinated-locomotion-manipulation-planning",children:"Coordinated Locomotion-Manipulation Planning"}),"\n",(0,a.jsx)(e.p,{children:"For humanoid robots, coordinating walking and manipulation is essential:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'class CoordinatedPlanner:\n    def __init__(self, locomotion_planner, manipulation_planner):\n        self.loco_planner = locomotion_planner\n        self.mani_planner = manipulation_planner\n        \n    def plan_task(self, goal_location, object_to_manipulate):\n        """\n        Plan coordinated task involving both locomotion and manipulation\n        """\n        # 1. Plan path to approach the object\n        navigation_plan = self.loco_planner.plan_to_object(\n            object_to_manipulate[\'location\']\n        )\n        \n        # 2. Plan manipulation at the location\n        manipulation_plan = self.mani_planner.plan_grasp(object_to_manipulate[\'pose\'])\n        \n        # 3. Coordinate the plans to ensure balance during manipulation\n        coordinated_plan = self.coordinate_loco_mani(navigation_plan, manipulation_plan)\n        \n        return coordinated_plan\n        \n    def coordinate_loco_mani(self, navigation_plan, manipulation_plan):\n        """\n        Coordinate locomotion and manipulation to maintain stability\n        """\n        # Simplified coordination strategy:\n        # - Stop locomotion during manipulation\n        # - Use upper body for manipulation while maintaining base stability\n        \n        # In practice, this would implement more sophisticated coordination\n        # such as dynamic balancing or anticipatory postural adjustments\n        \n        return {\n            \'navigation_plan\': navigation_plan,\n            \'manipulation_plan\': manipulation_plan,\n            \'timing\': self.calculate_timing(navigation_plan, manipulation_plan)\n        }\n        \n    def calculate_timing(self, nav_plan, mani_plan):\n        """\n        Calculate timing to coordinate locomotion and manipulation\n        """\n        # Simplified timing calculation\n        return {\n            \'start_manipulation_at_step\': len(nav_plan) // 2,\n            \'manipulation_duration\': len(mani_plan) * 0.1  # 0.1s per step\n        }\n'})}),"\n",(0,a.jsx)(e.p,{children:"Vision-Language-Action (VLA) models represent the cutting edge of robotics research, enabling robots to understand and respond to natural language commands through coordinated physical actions. By combining the power of large language models with perception and control systems, VLA systems are bringing us closer to truly general-purpose robots that can interact naturally with humans in complex environments."}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"This chapter has explored the critical VLA systems that bridge language understanding with physical action in robotics. From LLM-based planning to speech-to-action pipelines and coordinated locomotion-manipulation planning, these technologies are essential for creating robots that can effectively interact with the physical world through natural language commands. The next chapter will integrate all these concepts in a capstone project to build an autonomous humanoid system."})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>s,x:()=>r});var i=o(6540);const a={},t=i.createContext(a);function s(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:s(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);